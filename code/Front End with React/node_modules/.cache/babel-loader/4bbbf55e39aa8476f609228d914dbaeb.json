{"ast":null,"code":"// Block quotes\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      wasOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos++) !== 0x3E\n  /* > */\n  ) {\n      return false;\n    } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  } // skip spaces after \">\" and re-calculate offset\n\n\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]); // skip one optional space after '>'\n\n  if (state.src.charCodeAt(pos) === 0x20\n  /* space */\n  ) {\n      // ' >   test '\n      //     ^ -- position start of line here:\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n      spaceAfterMarker = true;\n    } else if (state.src.charCodeAt(pos) === 0x09\n  /* tab */\n  ) {\n      spaceAfterMarker = true;\n\n      if ((state.bsCount[startLine] + offset) % 4 === 3) {\n        // '  >\\t  test '\n        //       ^ -- position start of line here (tab has width===1)\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n      } else {\n        // ' >\\t  test '\n        //    ^ -- position start of line here + shift bsCount slightly\n        //         to make extra space appear\n        adjustTab = true;\n      }\n    } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [state.bsCount[startLine]];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n  lastLineEmpty = pos >= max;\n  oldSCount = [state.sCount[startLine]];\n  state.sCount[startLine] = offset - initial;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  wasOutdented = false; // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    && !wasOutdented) {\n      // This line is inside the blockquote.\n      // skip spaces after \">\" and re-calculate offset\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]); // skip one optional space after '>'\n\n      if (state.src.charCodeAt(pos) === 0x20\n      /* space */\n      ) {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n          spaceAfterMarker = true;\n        } else if (state.src.charCodeAt(pos) === 0x09\n      /* tab */\n      ) {\n          spaceAfterMarker = true;\n\n          if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n            offset++;\n            adjustTab = false;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]); // A negative indentation means that this is a paragraph continuation\n    //\n\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  token = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map = lines = [startLine, 0];\n  state.md.block.tokenize(state, startLine, nextLine);\n  token = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n};","map":{"version":3,"sources":["/Users/yaozixuan/OneDrive/JHU Semester 2/OOSE/my-app/node_modules/markdown-it/lib/rules_block/blockquote.js"],"names":["isSpace","require","module","exports","blockquote","state","startLine","endLine","silent","adjustTab","ch","i","initial","l","lastLineEmpty","lines","nextLine","offset","oldBMarks","oldBSCount","oldIndent","oldParentType","oldSCount","oldTShift","spaceAfterMarker","terminate","terminatorRules","token","wasOutdented","oldLineMax","lineMax","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","src","charCodeAt","bsCount","md","block","ruler","getRules","parentType","push","length","markup","map","tokenize","line"],"mappings":"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","sourcesContent":["// Block quotes\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      wasOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip spaces after \">\" and re-calculate offset\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  wasOutdented = false;\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !wasOutdented) {\n      // This line is inside the blockquote.\n\n      // skip spaces after \">\" and re-calculate offset\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}