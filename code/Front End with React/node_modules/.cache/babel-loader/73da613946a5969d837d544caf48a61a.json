{"ast":null,"code":"// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level,\n      found,\n      marker,\n      prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n\n    if (marker === 0x5D\n    /* ] */\n    ) {\n        level--;\n\n        if (level === 0) {\n          found = true;\n          break;\n        }\n      }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n\n    if (marker === 0x5B\n    /* [ */\n    ) {\n        if (prevPos === state.pos - 1) {\n          // increase level if we find text `[`, which is not a part of any token\n          level++;\n        } else if (disableNested) {\n          state.pos = oldPos;\n          return -1;\n        }\n      }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  } // restore old state\n\n\n  state.pos = oldPos;\n  return labelEnd;\n};","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it/lib/helpers/parse_link_label.js"],"names":["module","exports","parseLinkLabel","state","start","disableNested","level","found","marker","prevPos","labelEnd","max","posMax","oldPos","pos","src","charCodeAt","md","inline","skipToken"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,KAA/B,EAAsCC,aAAtC,EAAqD;AACpE,MAAIC,KAAJ;AAAA,MAAWC,KAAX;AAAA,MAAkBC,MAAlB;AAAA,MAA0BC,OAA1B;AAAA,MACIC,QAAQ,GAAG,CAAC,CADhB;AAAA,MAEIC,GAAG,GAAGR,KAAK,CAACS,MAFhB;AAAA,MAGIC,MAAM,GAAGV,KAAK,CAACW,GAHnB;AAKAX,EAAAA,KAAK,CAACW,GAAN,GAAYV,KAAK,GAAG,CAApB;AACAE,EAAAA,KAAK,GAAG,CAAR;;AAEA,SAAOH,KAAK,CAACW,GAAN,GAAYH,GAAnB,EAAwB;AACtBH,IAAAA,MAAM,GAAGL,KAAK,CAACY,GAAN,CAAUC,UAAV,CAAqBb,KAAK,CAACW,GAA3B,CAAT;;AACA,QAAIN,MAAM,KAAK;AAAK;AAApB,MAA6B;AAC3BF,QAAAA,KAAK;;AACL,YAAIA,KAAK,KAAK,CAAd,EAAiB;AACfC,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;;AAEDE,IAAAA,OAAO,GAAGN,KAAK,CAACW,GAAhB;AACAX,IAAAA,KAAK,CAACc,EAAN,CAASC,MAAT,CAAgBC,SAAhB,CAA0BhB,KAA1B;;AACA,QAAIK,MAAM,KAAK;AAAK;AAApB,MAA6B;AAC3B,YAAIC,OAAO,KAAKN,KAAK,CAACW,GAAN,GAAY,CAA5B,EAA+B;AAC7B;AACAR,UAAAA,KAAK;AACN,SAHD,MAGO,IAAID,aAAJ,EAAmB;AACxBF,UAAAA,KAAK,CAACW,GAAN,GAAYD,MAAZ;AACA,iBAAO,CAAC,CAAR;AACD;AACF;AACF;;AAED,MAAIN,KAAJ,EAAW;AACTG,IAAAA,QAAQ,GAAGP,KAAK,CAACW,GAAjB;AACD,GAlCmE,CAoCpE;;;AACAX,EAAAA,KAAK,CAACW,GAAN,GAAYD,MAAZ;AAEA,SAAOH,QAAP;AACD,CAxCD","sourcesContent":["// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n"]},"metadata":{},"sourceType":"script"}