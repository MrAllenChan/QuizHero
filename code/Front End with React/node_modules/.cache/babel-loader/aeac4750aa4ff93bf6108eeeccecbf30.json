{"ast":null,"code":"'use strict';\n\nvar normalizeReference = require('../common/utils').normalizeReference;\n\nvar isSpace = require('../common/utils').isSpace;\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    } // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n\n\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D\n    /* ] */\n    && state.src.charCodeAt(pos - 1) !== 0x5C\n    /* \\ */\n    ) {\n        if (pos + 1 === max) {\n          return false;\n        }\n\n        if (state.src.charCodeAt(pos + 1) !== 0x3A\n        /* : */\n        ) {\n            return false;\n          }\n\n        break;\n      }\n  }\n\n  endLine = state.lineMax; // jump line-by-line until empty one or EOF\n\n  terminatorRules = state.md.block.ruler.getRules('reference');\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    } // quirk for blockquotes, this line should already be checked by that rule\n\n\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    } // Some tags can terminate paragraph without empty line.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n\n    if (ch === 0x5B\n    /* [ */\n    ) {\n        return false;\n      } else if (ch === 0x5D\n    /* ] */\n    ) {\n        labelEnd = pos;\n        break;\n      } else if (ch === 0x0A\n    /* \\n */\n    ) {\n        lines++;\n      } else if (ch === 0x5C\n    /* \\ */\n    ) {\n        pos++;\n\n        if (pos < max && str.charCodeAt(pos) === 0x0A) {\n          lines++;\n        }\n      }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return false;\n    } // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n\n\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n\n  if (!res.ok) {\n    return false;\n  }\n\n  href = state.md.normalizeLink(res.str);\n\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n\n  pos = res.pos;\n  lines += res.lines; // save cursor state, we could require to rollback later\n\n  destEndPos = pos;\n  destEndLineNo = lines; // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n\n  start = pos;\n\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n\n\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  } // skip trailing spaces until the rest of the line\n\n\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      break;\n    }\n\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n\n        if (!isSpace(ch)) {\n          break;\n        }\n\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  } // Reference can not terminate anything. This check is for safety only.\n\n  /*istanbul ignore if*/\n\n\n  if (silent) {\n    return true;\n  }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n\n  state.parentType = oldParentType;\n  state.line = startLine + lines + 1;\n  return true;\n};","map":{"version":3,"sources":["/Users/yaozixuan/OneDrive/JHU Semester 2/OOSE/my-app/node_modules/markdown-it/lib/rules_block/reference.js"],"names":["normalizeReference","require","isSpace","module","exports","reference","state","startLine","_endLine","silent","ch","destEndPos","destEndLineNo","endLine","href","i","l","label","labelEnd","oldParentType","res","start","str","terminate","terminatorRules","title","lines","pos","bMarks","tShift","max","eMarks","nextLine","sCount","blkIndent","src","charCodeAt","lineMax","md","block","ruler","getRules","parentType","isEmpty","length","getLines","trim","helpers","parseLinkDestination","ok","normalizeLink","validateLink","parseLinkTitle","slice","env","references","line"],"mappings":"AAAA;;AAGA,IAAIA,kBAAkB,GAAKC,OAAO,CAAC,iBAAD,CAAP,CAA2BD,kBAAtD;;AACA,IAAIE,OAAO,GAAgBD,OAAO,CAAC,iBAAD,CAAP,CAA2BC,OAAtD;;AAGAC,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,SAA1B,EAAqCC,QAArC,EAA+CC,MAA/C,EAAuD;AACtE,MAAIC,EAAJ;AAAA,MACIC,UADJ;AAAA,MAEIC,aAFJ;AAAA,MAGIC,OAHJ;AAAA,MAIIC,IAJJ;AAAA,MAKIC,CALJ;AAAA,MAMIC,CANJ;AAAA,MAOIC,KAPJ;AAAA,MAQIC,QARJ;AAAA,MASIC,aATJ;AAAA,MAUIC,GAVJ;AAAA,MAWIC,KAXJ;AAAA,MAYIC,GAZJ;AAAA,MAaIC,SAbJ;AAAA,MAcIC,eAdJ;AAAA,MAeIC,KAfJ;AAAA,MAgBIC,KAAK,GAAG,CAhBZ;AAAA,MAiBIC,GAAG,GAAGrB,KAAK,CAACsB,MAAN,CAAarB,SAAb,IAA0BD,KAAK,CAACuB,MAAN,CAAatB,SAAb,CAjBpC;AAAA,MAkBIuB,GAAG,GAAGxB,KAAK,CAACyB,MAAN,CAAaxB,SAAb,CAlBV;AAAA,MAmBIyB,QAAQ,GAAGzB,SAAS,GAAG,CAnB3B,CADsE,CAsBtE;;AACA,MAAID,KAAK,CAAC2B,MAAN,CAAa1B,SAAb,IAA0BD,KAAK,CAAC4B,SAAhC,IAA6C,CAAjD,EAAoD;AAAE,WAAO,KAAP;AAAe;;AAErE,MAAI5B,KAAK,CAAC6B,GAAN,CAAUC,UAAV,CAAqBT,GAArB,MAA8B;AAAI;AAAtC,IAA+C;AAAE,aAAO,KAAP;AAAe,KAzBM,CA2BtE;AACA;;;AACA,SAAO,EAAEA,GAAF,GAAQG,GAAf,EAAoB;AAClB,QAAIxB,KAAK,CAAC6B,GAAN,CAAUC,UAAV,CAAqBT,GAArB,MAA8B;AAAK;AAAnC,OACArB,KAAK,CAAC6B,GAAN,CAAUC,UAAV,CAAqBT,GAAG,GAAG,CAA3B,MAAkC;AAAI;AAD1C,MACmD;AACjD,YAAIA,GAAG,GAAG,CAAN,KAAYG,GAAhB,EAAqB;AAAE,iBAAO,KAAP;AAAe;;AACtC,YAAIxB,KAAK,CAAC6B,GAAN,CAAUC,UAAV,CAAqBT,GAAG,GAAG,CAA3B,MAAkC;AAAI;AAA1C,UAAmD;AAAE,mBAAO,KAAP;AAAe;;AACpE;AACD;AACF;;AAEDd,EAAAA,OAAO,GAAGP,KAAK,CAAC+B,OAAhB,CAtCsE,CAwCtE;;AACAb,EAAAA,eAAe,GAAGlB,KAAK,CAACgC,EAAN,CAASC,KAAT,CAAeC,KAAf,CAAqBC,QAArB,CAA8B,WAA9B,CAAlB;AAEAtB,EAAAA,aAAa,GAAGb,KAAK,CAACoC,UAAtB;AACApC,EAAAA,KAAK,CAACoC,UAAN,GAAmB,WAAnB;;AAEA,SAAOV,QAAQ,GAAGnB,OAAX,IAAsB,CAACP,KAAK,CAACqC,OAAN,CAAcX,QAAd,CAA9B,EAAuDA,QAAQ,EAA/D,EAAmE;AACjE;AACA;AACA,QAAI1B,KAAK,CAAC2B,MAAN,CAAaD,QAAb,IAAyB1B,KAAK,CAAC4B,SAA/B,GAA2C,CAA/C,EAAkD;AAAE;AAAW,KAHE,CAKjE;;;AACA,QAAI5B,KAAK,CAAC2B,MAAN,CAAaD,QAAb,IAAyB,CAA7B,EAAgC;AAAE;AAAW,KANoB,CAQjE;;;AACAT,IAAAA,SAAS,GAAG,KAAZ;;AACA,SAAKR,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGQ,eAAe,CAACoB,MAAhC,EAAwC7B,CAAC,GAAGC,CAA5C,EAA+CD,CAAC,EAAhD,EAAoD;AAClD,UAAIS,eAAe,CAACT,CAAD,CAAf,CAAmBT,KAAnB,EAA0B0B,QAA1B,EAAoCnB,OAApC,EAA6C,IAA7C,CAAJ,EAAwD;AACtDU,QAAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;;AACD,QAAIA,SAAJ,EAAe;AAAE;AAAQ;AAC1B;;AAEDD,EAAAA,GAAG,GAAGhB,KAAK,CAACuC,QAAN,CAAetC,SAAf,EAA0ByB,QAA1B,EAAoC1B,KAAK,CAAC4B,SAA1C,EAAqD,KAArD,EAA4DY,IAA5D,EAAN;AACAhB,EAAAA,GAAG,GAAGR,GAAG,CAACsB,MAAV;;AAEA,OAAKjB,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGG,GAApB,EAAyBH,GAAG,EAA5B,EAAgC;AAC9BjB,IAAAA,EAAE,GAAGY,GAAG,CAACc,UAAJ,CAAeT,GAAf,CAAL;;AACA,QAAIjB,EAAE,KAAK;AAAK;AAAhB,MAAyB;AACvB,eAAO,KAAP;AACD,OAFD,MAEO,IAAIA,EAAE,KAAK;AAAK;AAAhB,MAAyB;AAC9BQ,QAAAA,QAAQ,GAAGS,GAAX;AACA;AACD,OAHM,MAGA,IAAIjB,EAAE,KAAK;AAAK;AAAhB,MAA0B;AAC/BgB,QAAAA,KAAK;AACN,OAFM,MAEA,IAAIhB,EAAE,KAAK;AAAK;AAAhB,MAAyB;AAC9BiB,QAAAA,GAAG;;AACH,YAAIA,GAAG,GAAGG,GAAN,IAAaR,GAAG,CAACc,UAAJ,CAAeT,GAAf,MAAwB,IAAzC,EAA+C;AAC7CD,UAAAA,KAAK;AACN;AACF;AACF;;AAED,MAAIR,QAAQ,GAAG,CAAX,IAAgBI,GAAG,CAACc,UAAJ,CAAelB,QAAQ,GAAG,CAA1B,MAAiC;AAAI;AAAzD,IAAkE;AAAE,aAAO,KAAP;AAAe,KArFb,CAuFtE;AACA;;;AACA,OAAKS,GAAG,GAAGT,QAAQ,GAAG,CAAtB,EAAyBS,GAAG,GAAGG,GAA/B,EAAoCH,GAAG,EAAvC,EAA2C;AACzCjB,IAAAA,EAAE,GAAGY,GAAG,CAACc,UAAJ,CAAeT,GAAf,CAAL;;AACA,QAAIjB,EAAE,KAAK,IAAX,EAAiB;AACfgB,MAAAA,KAAK;AACN,KAFD,MAEO,IAAIxB,OAAO,CAACQ,EAAD,CAAX,EAAiB;AACtB;AACD,KAFM,MAEA;AACL;AACD;AACF,GAlGqE,CAoGtE;AACA;;;AACAU,EAAAA,GAAG,GAAGd,KAAK,CAACgC,EAAN,CAASS,OAAT,CAAiBC,oBAAjB,CAAsC1B,GAAtC,EAA2CK,GAA3C,EAAgDG,GAAhD,CAAN;;AACA,MAAI,CAACV,GAAG,CAAC6B,EAAT,EAAa;AAAE,WAAO,KAAP;AAAe;;AAE9BnC,EAAAA,IAAI,GAAGR,KAAK,CAACgC,EAAN,CAASY,aAAT,CAAuB9B,GAAG,CAACE,GAA3B,CAAP;;AACA,MAAI,CAAChB,KAAK,CAACgC,EAAN,CAASa,YAAT,CAAsBrC,IAAtB,CAAL,EAAkC;AAAE,WAAO,KAAP;AAAe;;AAEnDa,EAAAA,GAAG,GAAGP,GAAG,CAACO,GAAV;AACAD,EAAAA,KAAK,IAAIN,GAAG,CAACM,KAAb,CA7GsE,CA+GtE;;AACAf,EAAAA,UAAU,GAAGgB,GAAb;AACAf,EAAAA,aAAa,GAAGc,KAAhB,CAjHsE,CAmHtE;AACA;;AACAL,EAAAA,KAAK,GAAGM,GAAR;;AACA,SAAOA,GAAG,GAAGG,GAAb,EAAkBH,GAAG,EAArB,EAAyB;AACvBjB,IAAAA,EAAE,GAAGY,GAAG,CAACc,UAAJ,CAAeT,GAAf,CAAL;;AACA,QAAIjB,EAAE,KAAK,IAAX,EAAiB;AACfgB,MAAAA,KAAK;AACN,KAFD,MAEO,IAAIxB,OAAO,CAACQ,EAAD,CAAX,EAAiB;AACtB;AACD,KAFM,MAEA;AACL;AACD;AACF,GA/HqE,CAiItE;AACA;;;AACAU,EAAAA,GAAG,GAAGd,KAAK,CAACgC,EAAN,CAASS,OAAT,CAAiBK,cAAjB,CAAgC9B,GAAhC,EAAqCK,GAArC,EAA0CG,GAA1C,CAAN;;AACA,MAAIH,GAAG,GAAGG,GAAN,IAAaT,KAAK,KAAKM,GAAvB,IAA8BP,GAAG,CAAC6B,EAAtC,EAA0C;AACxCxB,IAAAA,KAAK,GAAGL,GAAG,CAACE,GAAZ;AACAK,IAAAA,GAAG,GAAGP,GAAG,CAACO,GAAV;AACAD,IAAAA,KAAK,IAAIN,GAAG,CAACM,KAAb;AACD,GAJD,MAIO;AACLD,IAAAA,KAAK,GAAG,EAAR;AACAE,IAAAA,GAAG,GAAGhB,UAAN;AACAe,IAAAA,KAAK,GAAGd,aAAR;AACD,GA5IqE,CA8ItE;;;AACA,SAAOe,GAAG,GAAGG,GAAb,EAAkB;AAChBpB,IAAAA,EAAE,GAAGY,GAAG,CAACc,UAAJ,CAAeT,GAAf,CAAL;;AACA,QAAI,CAACzB,OAAO,CAACQ,EAAD,CAAZ,EAAkB;AAAE;AAAQ;;AAC5BiB,IAAAA,GAAG;AACJ;;AAED,MAAIA,GAAG,GAAGG,GAAN,IAAaR,GAAG,CAACc,UAAJ,CAAeT,GAAf,MAAwB,IAAzC,EAA+C;AAC7C,QAAIF,KAAJ,EAAW;AACT;AACA;AACAA,MAAAA,KAAK,GAAG,EAAR;AACAE,MAAAA,GAAG,GAAGhB,UAAN;AACAe,MAAAA,KAAK,GAAGd,aAAR;;AACA,aAAOe,GAAG,GAAGG,GAAb,EAAkB;AAChBpB,QAAAA,EAAE,GAAGY,GAAG,CAACc,UAAJ,CAAeT,GAAf,CAAL;;AACA,YAAI,CAACzB,OAAO,CAACQ,EAAD,CAAZ,EAAkB;AAAE;AAAQ;;AAC5BiB,QAAAA,GAAG;AACJ;AACF;AACF;;AAED,MAAIA,GAAG,GAAGG,GAAN,IAAaR,GAAG,CAACc,UAAJ,CAAeT,GAAf,MAAwB,IAAzC,EAA+C;AAC7C;AACA,WAAO,KAAP;AACD;;AAEDV,EAAAA,KAAK,GAAGjB,kBAAkB,CAACsB,GAAG,CAAC+B,KAAJ,CAAU,CAAV,EAAanC,QAAb,CAAD,CAA1B;;AACA,MAAI,CAACD,KAAL,EAAY;AACV;AACA,WAAO,KAAP;AACD,GA7KqE,CA+KtE;;AACA;;;AACA,MAAIR,MAAJ,EAAY;AAAE,WAAO,IAAP;AAAc;;AAE5B,MAAI,OAAOH,KAAK,CAACgD,GAAN,CAAUC,UAAjB,KAAgC,WAApC,EAAiD;AAC/CjD,IAAAA,KAAK,CAACgD,GAAN,CAAUC,UAAV,GAAuB,EAAvB;AACD;;AACD,MAAI,OAAOjD,KAAK,CAACgD,GAAN,CAAUC,UAAV,CAAqBtC,KAArB,CAAP,KAAuC,WAA3C,EAAwD;AACtDX,IAAAA,KAAK,CAACgD,GAAN,CAAUC,UAAV,CAAqBtC,KAArB,IAA8B;AAAEQ,MAAAA,KAAK,EAAEA,KAAT;AAAgBX,MAAAA,IAAI,EAAEA;AAAtB,KAA9B;AACD;;AAEDR,EAAAA,KAAK,CAACoC,UAAN,GAAmBvB,aAAnB;AAEAb,EAAAA,KAAK,CAACkD,IAAN,GAAajD,SAAS,GAAGmB,KAAZ,GAAoB,CAAjC;AACA,SAAO,IAAP;AACD,CA9LD","sourcesContent":["'use strict';\n\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}