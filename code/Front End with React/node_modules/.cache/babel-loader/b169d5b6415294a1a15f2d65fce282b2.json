{"ast":null,"code":"// Inline parser state\n'use strict';\n\nvar Token = require('../token');\n\nvar isWhiteSpace = require('../common/utils').isWhiteSpace;\n\nvar isPunctChar = require('../common/utils').isPunctChar;\n\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n\n  this.cache = {}; // List of emphasis-like delimiters for current tag\n\n  this.delimiters = []; // Stack of delimiter lists for upper level tags\n\n  this._prev_delimiters = [];\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n\n    this._prev_delimiters.push(this.delimiters);\n\n    this.delimiters = [];\n    token_meta = {\n      delimiters: this.delimiters\n    };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n}; // Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\n\n\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start,\n      lastChar,\n      nextChar,\n      count,\n      can_open,\n      can_close,\n      isLastWhiteSpace,\n      isLastPunctChar,\n      isNextWhiteSpace,\n      isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start); // treat beginning of the line as a whitespace\n\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  count = pos - start; // treat end of the line as a whitespace\n\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n  } else {\n    can_open = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    length: count\n  };\n}; // re-export Token class to use in block rules\n\n\nStateInline.prototype.Token = Token;\nmodule.exports = StateInline;","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it/lib/rules_inline/state_inline.js"],"names":["Token","require","isWhiteSpace","isPunctChar","isMdAsciiPunct","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","prototype","pushPending","token","content","push","type","tag","nesting","token_meta","pop","scanDelims","start","canSplitWord","lastChar","nextChar","count","can_open","can_close","isLastWhiteSpace","isLastPunctChar","isNextWhiteSpace","isNextPunctChar","left_flanking","right_flanking","max","marker","charCodeAt","String","fromCharCode","module","exports"],"mappings":"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","sourcesContent":["// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n"]},"metadata":{},"sourceType":"script"}