{"ast":null,"code":"// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n'use strict';\n\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\n\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\nmodule.exports = function linkify(state) {\n  var i,\n      j,\n      l,\n      tokens,\n      token,\n      currentToken,\n      nodes,\n      ln,\n      text,\n      pos,\n      lastPos,\n      level,\n      htmlLinkLevel,\n      url,\n      fullUrl,\n      urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) {\n    return;\n  }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n    htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i]; // Skip content of markdown links\n\n      if (currentToken.type === 'link_close') {\n        i--;\n\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n\n        continue;\n      } // Skip content of html tag links\n\n\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n        text = currentToken.content;\n        links = state.md.linkify.match(text); // Now split string to nodes\n\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n\n          if (!state.md.validateLink(fullUrl)) {\n            continue;\n          }\n\n          urlText = links[ln].text; // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level = level;\n            nodes.push(token);\n          }\n\n          token = new state.Token('link_open', 'a', 1);\n          token.attrs = [['href', fullUrl]];\n          token.level = level++;\n          token.markup = 'linkify';\n          token.info = 'auto';\n          nodes.push(token);\n          token = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level = level;\n          nodes.push(token);\n          token = new state.Token('link_close', 'a', -1);\n          token.level = --level;\n          token.markup = 'linkify';\n          token.info = 'auto';\n          nodes.push(token);\n          lastPos = links[ln].lastIndex;\n        }\n\n        if (lastPos < text.length) {\n          token = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level = level;\n          nodes.push(token);\n        } // replace current node\n\n\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it/lib/rules_core/linkify.js"],"names":["arrayReplaceAt","require","isLinkOpen","str","test","isLinkClose","module","exports","linkify","state","i","j","l","tokens","token","currentToken","nodes","ln","text","pos","lastPos","level","htmlLinkLevel","url","fullUrl","urlText","blockTokens","links","md","options","length","type","pretest","content","children","match","normalizeLink","validateLink","schema","normalizeLinkText","replace","index","Token","slice","push","attrs","markup","info","lastIndex"],"mappings":"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","sourcesContent":["// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}