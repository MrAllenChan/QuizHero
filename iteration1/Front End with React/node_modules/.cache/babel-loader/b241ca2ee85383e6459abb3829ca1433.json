{"ast":null,"code":"// Lists\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace; // Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n  marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n      return -1;\n    }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine]; // List marker should have at least 2 chars (digit + dot)\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n      return -1;\n    }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        // List marker should have no more than 9 digits\n        // (prevents integer overflow in browsers)\n        if (pos - start >= 10) {\n          return -1;\n        }\n\n        continue;\n      } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n        break;\n      }\n\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  } // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n\n\n  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n    return false;\n  } // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n\n\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  } // Detect list type and position after marker\n\n\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1)); // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  } // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n\n\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately\n\n  if (silent) {\n    return true;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token = state.push('ordered_list_open', 'ol', 1);\n\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]];\n    }\n  } else {\n    token = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map = listLines = [startLine, 0];\n  token.markup = String.fromCharCode(markerCharCode); //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    indent = initial + indentAfterMarker; // Run subparser & write tokens\n\n    token = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map = itemLines = [startLine, 0]; // change current state, then restore it after parser subcall\n\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine]; //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    } // If any of list item is tight, mark list as tight\n\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n    token = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    } // if it's indented more than 3 spaces, it should be a code block\n\n\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n      break;\n    } // fail if terminating block found\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finalize list\n\n\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n\n  token.markup = String.fromCharCode(markerCharCode);\n  listLines[1] = nextLine;\n  state.line = nextLine;\n  state.parentType = oldParentType; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it/lib/rules_block/list.js"],"names":["isSpace","require","skipBulletListMarker","state","startLine","marker","pos","max","ch","bMarks","tShift","eMarks","src","charCodeAt","skipOrderedListMarker","start","markTightParagraphs","idx","i","l","level","tokens","length","type","hidden","module","exports","list","endLine","silent","contentStart","indent","indentAfterMarker","initial","isOrdered","itemLines","listLines","listTokIdx","markerCharCode","markerValue","nextLine","offset","oldListIndent","oldParentType","oldSCount","oldTShift","oldTight","posAfterMarker","prevEmptyEnd","terminate","terminatorRules","token","isTerminatingParagraph","tight","sCount","blkIndent","listIndent","parentType","Number","substr","skipSpaces","push","attrs","map","markup","String","fromCharCode","md","block","ruler","getRules","bsCount","isEmpty","line","Math","min","tokenize"],"mappings":"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","sourcesContent":["// Lists\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[startLine] - state.listIndent >= 4 &&\n      state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n\n    // change current state, then restore it after parser subcall\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}