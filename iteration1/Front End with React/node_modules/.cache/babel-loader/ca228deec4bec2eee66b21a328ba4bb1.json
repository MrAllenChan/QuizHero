{"ast":null,"code":"// lheading (---, ===)\n'use strict';\n\nmodule.exports = function lheading(state, startLine, endLine\n/*, silent*/\n) {\n  var content,\n      terminate,\n      i,\n      l,\n      token,\n      pos,\n      max,\n      level,\n      marker,\n      nextLine = startLine + 1,\n      oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'); // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n  // jump line-by-line until empty one or EOF\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    } //\n    // Check for underline in setext header\n    //\n\n\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D\n        /* - */\n        || marker === 0x3D\n        /* = */\n        ) {\n            pos = state.skipChars(pos, marker);\n            pos = state.skipSpaces(pos);\n\n            if (pos >= max) {\n              level = marker === 0x3D\n              /* = */\n              ? 1 : 2;\n              break;\n            }\n          }\n      }\n    } // quirk for blockquotes, this line should already be checked by that rule\n\n\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    } // Some tags can terminate paragraph without empty line.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine + 1;\n  token = state.push('heading_open', 'h' + String(level), 1);\n  token.markup = String.fromCharCode(marker);\n  token.map = [startLine, state.line];\n  token = state.push('inline', '', 0);\n  token.content = content;\n  token.map = [startLine, state.line - 1];\n  token.children = [];\n  token = state.push('heading_close', 'h' + String(level), -1);\n  token.markup = String.fromCharCode(marker);\n  state.parentType = oldParentType;\n  return true;\n};","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it/lib/rules_block/lheading.js"],"names":["module","exports","lheading","state","startLine","endLine","content","terminate","i","l","token","pos","max","level","marker","nextLine","oldParentType","terminatorRules","md","block","ruler","getRules","sCount","blkIndent","parentType","isEmpty","bMarks","tShift","eMarks","src","charCodeAt","skipChars","skipSpaces","length","getLines","trim","line","push","String","markup","fromCharCode","map","children"],"mappings":"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","sourcesContent":["// lheading (---, ===)\n\n'use strict';\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1, oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}