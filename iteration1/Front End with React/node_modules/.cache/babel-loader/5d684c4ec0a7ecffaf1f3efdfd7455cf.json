{"ast":null,"code":"// HTML block\n'use strict';\n\nvar block_names = require('../common/html_blocks');\n\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE; // An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\n\n\nvar HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\\?/, /\\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\\[CDATA\\[/, /\\]\\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'), /^$/, false]];\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i,\n      nextLine,\n      token,\n      lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  if (!state.md.options.html) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  ) {\n      return false;\n    }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) {\n      break;\n    }\n  }\n\n  if (i === HTML_SEQUENCES.length) {\n    return false;\n  }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1; // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) {\n        break;\n      }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) {\n          nextLine++;\n        }\n\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n  token = state.push('html_block', '', 0);\n  token.map = [startLine, nextLine];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n  return true;\n};","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it/lib/rules_block/html_block.js"],"names":["block_names","require","HTML_OPEN_CLOSE_TAG_RE","HTML_SEQUENCES","RegExp","join","source","module","exports","html_block","state","startLine","endLine","silent","i","nextLine","token","lineText","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","md","options","html","src","charCodeAt","slice","length","test","line","push","map","content","getLines"],"mappings":"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","sourcesContent":["// HTML block\n\n'use strict';\n\n\nvar block_names = require('../common/html_blocks');\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}