{"ast":null,"code":"// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx,\n      openerIdx,\n      closer,\n      opener,\n      minOpenerIdx,\n      newMinOpenerIdx,\n      isOddMatch,\n      lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx]; // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n\n    closer.length = closer.length || 0;\n    if (!closer.close) continue; // Previously calculated lower bounds (previous fails)\n    // for each marker and each delimiter length modulo 3.\n\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\n    newMinOpenerIdx = -1;\n    openerIdx = closerIdx - closer.jump - 1;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n      if (opener.marker !== closer.marker) continue;\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\n\n      if (opener.open && opener.end < 0 && opener.level === closer.level) {\n        isOddMatch = false; // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? delimiters[openerIdx - 1].jump + 1 : 0;\n          closer.jump = closerIdx - openerIdx + lastJump;\n          closer.open = false;\n          opener.end = closerIdx;\n          opener.jump = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};","map":{"version":3,"sources":["/Users/yaozixuan/OneDrive/JHU Semester 2/OOSE/my-app/node_modules/markdown-it/lib/rules_inline/balance_pairs.js"],"names":["processDelimiters","state","delimiters","closerIdx","openerIdx","closer","opener","minOpenerIdx","newMinOpenerIdx","isOddMatch","lastJump","openersBottom","max","length","close","hasOwnProperty","marker","jump","open","end","level","module","exports","link_pairs","curr","tokens_meta"],"mappings":"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","sourcesContent":["// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker and each delimiter length modulo 3.\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\n    newMinOpenerIdx = -1;\n\n    openerIdx = closerIdx - closer.jump - 1;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\n\n      if (opener.open &&\n          opener.end < 0 &&\n          opener.level === closer.level) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            delimiters[openerIdx - 1].jump + 1 :\n            0;\n\n          closer.jump  = closerIdx - openerIdx + lastJump;\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.jump  = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}